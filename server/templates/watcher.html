<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WebRTC Watcher</title>
    <link rel="stylesheet" href="style.css" />
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH"
      crossorigin="anonymous"
    />
  </head>

  <body>
    <div class="container-fluid bg-light">
      <div class="row">
        <div class="col-12 col-sm-3 col-lg-2">
          <div class="vh-100 overflow-y-scroll">
            <div id="container-video"></div>
          </div>
        </div>
        <div class="col-6 col-md-7">
          <div class="row justify-content-center">
            <div class="col-auto">
              <video
                id="viewer"
                autoplay
                muted
                class="img-fluid rounded vh-98 pt-1"
              ></video>
            </div>
          </div>
        </div>
        <div class="col-3 col-md-2 col-lg-2"></div>
      </div>
    </div>
  </body>

  <script
    src="https://cdn.socket.io/4.7.5/socket.io.min.js"
    integrity="sha384-2huaZvOR9iDzHqslqwpR87isEmrfxqyWOF7hr7BY6KG0+hVKLoEXMPUJw3ynWuhO"
    crossorigin="anonymous"
  ></script>
  <script src="index.js"></script>
  <script src="CardReload.js"></script>

  <script>
    const container = document.getElementById("container-video");
    const viewer = document.getElementById("viewer");
    const room = new Room("Video-streaming");
    socket.emit("watcher");
    room.onUpdate(() => {
      container.innerHTML = "";

      room.connections.forEach((connection, i) => {
        if (!viewer.srcObject && i === 0) {
          viewer.srcObject = connection.stream;
        }

        let state = connection.peerConnection.connectionState;
        let content = null;
        if (state === "connected") {
          content = document.createElement("video");
          content.className = "img-fluid rounded col-12 ratio ratio-1x1";
          content.autoplay = true;
          content.muted = true;
          content.volume = 0;
          content.srcObject = connection.stream;
          content.addEventListener(
            "click",
            () => (viewer.srcObject = connection.stream)
          );
        }
        if (state === "new" || state === "connecting") {
          content = ActionCard({
            icon: "loader",
            buttons: [
              {
                text: "Reload",
                color: "primary",
                onclick: () => {
                  console.log("watcher");
                  socket.emit("watcher");
                },
              },
            ],
          });
        }
        if (state === "failed") {
          content = ActionCard({
            icon: "danger-icon",
            buttons: [
              {
                text: "reload",
                color: "primary",
                onclick: () => {
                  console.log("watcher");
                  socket.emit("watcher");
                },
              },
              {
                text: "Delete",
                color: "danger",
                onclick: () => {
                  room.connections.splice(i, 1);
                  room.handlerUpdate();
                },
              },
            ],
          });
        }

        if (!content) {
          return;
        }
        container.appendChild(content);

        // remoteVideo.srcObject = connection.stream;
      });
      // console.log("e", connection.stream);
    });
    socket.on("broadcaster", () => {
      console.log("broadcaster");
      socket.emit("watcher");
    });

    socket.on("connect", () => {
      room.setId(socket.id);
    });
    socket.on("offer", async ({ to, from, offer }) => {
      room.offer(to, from, offer);
    });
    socket.on("candidate", async ({ to, from, candidate }) => {
      room.onCandidate(to, from, candidate);
    });

    // // const socket = io.connect("https://j9drrtjb-5000.euw.devtunnels.ms/");

    // // const socket = io.connect("http://127.0.0.1:5000/");
    // // const socket = io("http://127.0.0.1:5000/");
    // const socket = io("https://" + window.location.host, { secure: false });
    // let id = null;
    // let peerConnection;
    // const config = {
    //   iceServers: [
    //     { urls: "stun:stun.l.google.com:19302" },
    //     // {
    //     //   urls: "stun:stun.relay.metered.ca:80",
    //     // },
    //     // {
    //     //   urls: "turn:global.relay.metered.ca:80",
    //     //   username: "8dd074099f122d9108cf7547",
    //     //   credential: "8WuSKQ7RqzQ+jknR",
    //     // },
    //     // {
    //     //   urls: "turn:global.relay.metered.ca:80?transport=tcp",
    //     //   username: "8dd074099f122d9108cf7547",
    //     //   credential: "8WuSKQ7RqzQ+jknR",
    //     // },
    //     // {
    //     //   urls: "turn:global.relay.metered.ca:443",
    //     //   username: "8dd074099f122d9108cf7547",
    //     //   credential: "8WuSKQ7RqzQ+jknR",
    //     // },
    //     // {
    //     //   urls: "turns:global.relay.metered.ca:443?transport=tcp",
    //     //   username: "8dd074099f122d9108cf7547",
    //     //   credential: "8WuSKQ7RqzQ+jknR",
    //     // },
    //   ],
    // };
    // peerConnection = new RTCPeerConnection(config);
    // peerConnection.addEventListener("connectionstatechange", (event) => {
    //   console.log(`connection: ${peerConnection.connectionState}`);
    //   // alert(`connection: ${peerConnection.connectionState}`);
    // });
    // socket.on("offer", async (res) => {
    //   console.log("Offer broadcast");
    //   // console.log(res);

    //   peerConnection.onicecandidate = (event) => {
    //     if (event.candidate) {
    //       socket.emit("candidate", event.candidate);
    //     }
    //   };

    //   peerConnection.ontrack = (event) => {
    //     console.log("track");
    //     remoteVideo.srcObject = event.streams[0];
    //   };
    //   if (res.to !== socket.id) {
    //     return;
    //   }
    //   console.log("Set remote description");
    //   await peerConnection.setRemoteDescription(
    //     new RTCSessionDescription(res.offer)
    //   );
    //   const answer = await peerConnection.createAnswer();
    //   await peerConnection.setLocalDescription(answer);
    //   console.log("Sending answer");

    //   socket.emit("answer", answer);
    // });

    // socket.on("candidate", async (candidate) => {
    //   console.log("candidate");
    //   if (!peerConnection.remoteDescription) {
    //     return;
    //   }
    //   await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
    // });

    // socket.on("broadcaster", () => {
    //   console.log("Broadcaster detected");
    //   console.log("Sending watch req");
    //   socket.emit("watcher");
    // });

    // socket.on("connect", function (data) {
    //   console.log("Received ID:", socket.id);
    //   socket.emit("watcher");
    // });
    // socket.on("frame", (frame) => {
    //   let previous_date = new Date();
    //   const blob = new Blob([frame.buffer], { type: "image/jpeg" });
    //   const url = URL.createObjectURL(blob);
    //   const receivedImage = document.getElementById("receivedImage");
    //   receivedImage.src = url;
    //   let current_date = new Date();
    //   let second_diff =
    //     (current_date.getTime() - previous_date.getTime()) / 1000;
    //   console.log(frame);
    //   console.log("time: ", second_diff);
    // });

    // window.onunload = window.onbeforeunload = () => {
    //   socket.disconnect();
    // };
  </script>
</html>
